\section{Overview}

This chapter will explain the general concept and architecture of the traffic light control system developed with this thesis. The traffic light control system will be built upon an existing traffic simulation, because the thesis is not about the simulation, but the optimization of the traffic light control. Which simulation is chosen will be discussed in a later section of the thesis and is not really relevant here, but this architecture will influence which traffic simulation will be chosen. The requirements for the traffic simulation will be derived from this concept.

\begin{figure}[ht]
  \centering
  \includegraphics[width=16cm]{figures/architecture}
  \label{architecture}
  \caption[Architecture of the Traffic Light Control System]{Architecture of the Traffic Light Control System \protect\footnotemark}
\end{figure}

\footnotetext{own illustration}

The traffic light control system is separated into general areas, the learning part of the system and the controlling part. Either the system just observes a running traffic simulation and learns the patterns of the traffic or it observes the simulation through traffic sensors and controls the traffic lights according to the predictions combined with the data from the traffic sensors. It is imaginable to let the system learn from a simulation and control it at the same time, but this is outside of the scope of this thesis. But it could possibly improve the results and make it more practicable for a real world deployment.

The control part of the system is the more important. The learning is relatively simple and will be easily interchangeable. This is also the reason why the architecture was split into two parts. With the simulation the data to learn from will be recorded from the simulation itself, but in a real world scenario data could also be fed from other sources, thus the data collection in the learning part is not a main feature of the traffic light control system and was split from the core control part.

Spanning both the learning and the control part of the system is the prediction network. It is responsible for actually learning the traffic behavior and feeding predictions of the learned behavior back into a real simulation. For this task the prediction network will include an artificial neural network or multiple of them in some form, which is detailed in section \ref{predictionNetwork}. The prediction network will use unsupervised learning to learn the traffic patterns, meaning that there will not be labeled data sets collected beforehand or a continuous interaction with the simulation, but the data sets will be collected from a running traffic simulation.

The traffic recorder will collect such data sets and feed them into the prediction network. Depicted in figure \ref{architecture} is only the default implementation of the traffic recorder which collects the data sets directly from the traffic simulation. The design goal of this component is to split the learning set creation and handling from the prediction network to be flexible and extensible in how data is fed to the prediction network. The default implementation will observe the state of the traffic network and record the data that is compliant to the prediction networks input and output formats. With the component split from the prediction network the creation of data sets is clearly separated from the prediction network. Thus it is, as said earlier, possible to change the way data is fed to the prediction network easily. In a real world scenario it probably would be nearly impossible to automatically record the data sets and it would be a huge benefit to easily swap out the learning input to some other method, which is totally possible with this architecture.

In the control part of the system the interaction with the traffic simulation occurs over traffic sensors that collect data and the traffic light controller that switches the states of the traffic lights. The different traffic sensors that are commonly used already are detailed in section \ref{trafficSensors}. Depending on the traffic simulation software chosen later, they are already part of the simulation or have to be simulated by observing the state of the simulation an extracting the relevant information. The data they need from the simulation and the data they pass on to the next component depends on the type of sensor used. An induction loop may only report if a vehicle currently is on top of it or not, but a camera attached to the traffic light might even count the amount of vehicles waiting for the light to turn green. The traffic light controller has to switch the traffic lights depending on the input he gets from the traffic tracker and is further described in section \ref{trafficLightController}. Like the traffic recorder the goal here was to be able to swap out the layer communicating information to the main components of the traffic light control system. An additional goal for the traffic light controller was to be able to swap out the strategy that it uses to control the traffic lights, but this is discussed in more detail in section \ref{trafficLightController}.

The final component of the architecture is the traffic tracker that keeps all other components together. Its task is to use the prediction network and the traffic sensors to create a picture of reality that has to closely match what is really happening. The traffic tracker can then make a statement about where cars should be in the system an the traffic light controller can then, based upon the traffic trackers data, make decisions how the traffic lights have to be optimally switched. The difficulties arising in this component are various. For example, a traffic sensor could discover that a  prediction made by the prediction network is wrong. This has to be corrected somehow, but with a complex street network it may not be easy to detect where the failure came from. This problem is from now on called the error correction problem. Furthermore traffic sensors may give very vague or heterogeneous data, making it hard to incorporate the data into the picture of reality.

\begin{figure}[ht]
  \centering
  \includegraphics[width=16cm]{figures/errorCorrectionProblem}
  \label{errorCorrectionProblem}
  \caption[Error Correction Problem]{Error Correction Problem \protect\footnotemark}
\end{figure}

\footnotetext{own illustration}

Figure \ref{errorCorrectionProblem} shows an example for the error correction problem. In this example two vehicles V1 and V2 depicted in green entered at the road crossing C4. (1) Here the first prediction was that one car drives to C1 and the other one drives to C5. (2) This prediction is only based on the learned traffic patterns and could be completely wrong, but should in the most cases be right.

When V1 enters crossing C1 the prediction is that it drives to C2. The prediction for V2 is that it continues from C5 to C2. (3) In the example, crossing C6 is equipped with induction loops and detects when a vehicle enters the crossing.

Finally a vehicle is detected at C6, but in the traffic tracker all vehicles in the network are at other positions and no vehicle was predicted to drive there. This is not trivial to solve and could be solved in many different ways. Either V1 or V2 could be predicted wrong. The correction, if V2 would be wrong, is straight forward. V2 is just moved to the crossing, but if V1 is chosen to be moved there, it could have had implications on the prediction at crossing C5, where the prediction was made with one vehicle, but should then have been made with two. This could then spawn new errors in the network that would have to be resolved.

With this really simple example alone one can see how it is difficult to resolve errors in a complex network that are detected by traffic sensors. With more vehicles and more crossings the problem gets even bigger. A solution algorithm for these problems will be implemented by the traffic tracker which is discussed in more detail in section \ref{trafficTracker}.

With this architecture it should be possible to experiment with different traffic sensors and traffic light controllers. This is a huge benefit, because experimentation will especially be important when trying to find the best setup of sensors and controller when later evaluating different possibilities to use the traffic light control system.

\section{Traffic Light Controller}
\label{trafficLightController}

This component is the executive part of the architecture. It assembles the information gathered in the traffic network into traffic signal switching plans. Every street intersection, small or big, has its own controller instance managing just this intersection. One specific controller represents one specific switching strategy. The switching strategy can be decided on a per-intersection basis. This way a street network can be setup with differently controlled intersections in order to test mixed networks.

All controllers have a Traffic Network Controller as their parent, which can act as a communication bus between traffic light controllers. The network controller is also a lower-level (from the perspective of a per-intersection controller) integration into the simulation software and can capture generic events and direct them to affected local controllers, as it is the instance in the system that knows all intersection controllers.

A signal controller, or local controller, manages the intersections signals in a signal system, which holds the signals themselves as well as the signal groups including the mappings from groups to signals and signal to group.

This results in the entity relationships shown in \autoref{sig_ctrl_relations}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=13cm]{figures/signal_light_controller}
	\label{sig_ctrl_relations}
	\caption{Entity relationships inside the Traffic Light Controller}
\end{figure}

From now on the term ''signal controller`` will refer to the intersection local controllers. Its the responsibility of these controllers decide which lights to switch to green and for how long. In contrast to the commonly applied concepts of cycles and splits (as seen in \autoref{analysis}), these controllers will use a different approach. Instead of having a fixed cycle time separated into splits per phase, a priority queue like approach has been chosen to define the order of phases and a load based function is applied to decide the length of the given phase.

Even though the individual lanes and their sensor data will be used as input, switching is done on a signal group level. Signal groups will always be switched as one unit and as such, decisions are made not on a signal level, but considering all signals of a group.

\subsection*{Grouping signals}
\label{signal_group_concept}

In order to do signal switching on a group basis, the groups must be defined first. A simple yet effective approach to defining the signal groups of an intersection is to manually inspect the intersection and define the groups by hand. This allows very specific grouping rules and easy special casing where needed or beneficial. With only a few intersections (for example in a small town) this is an acceptable solution.

However as one of the goals of the project is to reduce manual input and the resulting advantages in large street networks with many intersections, an automated approach has been chosen. Signals can be groups in a lot of different ways depending on the intersection layout and applicable priority rules. In the real world, many intersections allow two green lanes to intersect each other, often seen when the intersecting lane is a low traffic lane. This increases the complexity of finding suitable groups and also poses a driver security risks, as opposing drivers may not expect an vehicle intersecting his lane.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=6cm]{figures/intersecting_green}
	\label{intersecting_green}
	\caption{Intersection pattern with intersecting green lanes (marked red).}
\end{figure}

\autoref{intersecting_green} shows a pattern that is common in German cities where the traffic to the opposing street is infrequent.

The approach chosen for in this project should not allow conflicting green lanes and thus increase driver safety. Two lanes are in conflict, if they either intersecting each other at any point or if they merge into one lane as part of the intersection. The line from the top to the bottom and the lane from the bottom to the left in \autoref{intersecting_green} would not be allowed, because they intersect. The lane from the top to the left and the lane from the bottom to the left don't intersect, but would still not be allowed in the same group, as they merge into one lane. The approach should also produce a minimal set of signal groups without any redundant groups. A groups redundant if it is entirely contained within another group.

As an high level algorithm, this would contain the following steps:

\begin{enumerate}
	\item Construct the set of all potential groups as the power set of the set of signals.
	\item Remove all groups that contain a signal pair with intersecting lanes
	\item Remove all groups that contain a signal pair with merging lanes
	\item Remove all groups that are contained within another group
	\item The remain groups are minimal and conflict free
\end{enumerate}

Building and filtering a power set is exponential ($\mathcal{O}(2^n)$) both in runtime and memory costs, however constructing the signal groups is usually done once for a given intersection and the number of signals is unlikely to become big enough, that the computation of the groups would not be possible in an acceptable amount of time. For an unrestricted intersection, which is the largest intersection for this project with twelve signals, the algorithm would produce the group patterns shown in \autoref{signal_group_pattern}. The patterns one to three can be rotated 3 times, the pattern four and five once, resulting in 17 unique signal groups.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=14cm]{figures/signal_group_patterns}
	\caption{Possible patterns of signal groups produced by the given algorithm. Most patterns can be rotated.}
	\label{signal_group_pattern}
\end{figure}

Further details of the algorithm and implementation specialties a further described in \autoref{scenario_generation}.

\subsection*{Priority}
\label{stress_prio}

In order to use a priority queue, there must be a measure of priority. The measure proposed for this is called a stress function referring to commuter stress (see \autoref{commuter_stress}). The idea is simple: Waiting for a long time in front of a red traffic light causes increasing amounts of stress and waiting in a very long queue is worse than waiting as the first vehicle in line.

As such we can define a stress function for an individual signal as follows: $s(n, t): \mathbb{R}^2 \mapsto \mathbb{R}$ with $n$ being the number of cars waiting at a signal and $t$ being the since the signal was last in the green state. The overall stress of a signal group is than calculated with $S(n, t)$ as seen in \autoref{group_stress}. $N$ is the number of signals in the group and $s\left(n_i, t_i\right)$ is the stress of the current signal. The main goal is, that the stress of a signal with a few vehicles waiting for a long time will eventually surpass the stress of a signal with a lot of vehicles waiting for a shorter time. 

\begin{equation}
	\label{group_stress}
	S(n, t) = \sum_{i}^{N}{s\left(n_i, t_i\right)}
\end{equation}

Including the wait/red time in the function is quite important. A naive approach could just use a the number of vehicles in front of the signals, but this can lead to starvation problems (certain lanes not getting any time at all), if two signal groups receive a lot of new vehicles in a short time while other groups only receive a small number of vehicles. In these cases the signal controller would oscillate between the two high input groups and completely ignore other groups until the input of these active groups decreases, which can take hours during a common ''rush hour`` on main streets.

A proposed definition for $s(n, t) $ is shown in \autoref{proposed_stress}. The value for $c$ can be is constant and should be freely chosen from $\mathbb{R}$ to guarantee a certain stress buildup per time unit even if no cars are detected at the signal. A visualization of this function can be seen in \autoref{stress_func_plot} with two values for $c$.

\begin{equation} \label{proposed_stress}
	s(n, t) = (n + t)(n + c)
\end{equation}

The number of cars has a quadratic influence while the time has a linear influence on the result which can also be seen in \autoref{stress_func_plot}.

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
		zmin=0,
		xlabel={Time},
		ylabel={Vehicle count},
		zlabel={Stress}
	]
	\addplot3[surf, samples=15, domain=0:150]{
		(x + y) * (x + 0.1)
	};
	\addplot3[mesh, samples=15, domain=0:150]{
		(x + y) * (x + 100)
	};
	\end{axis}
	\end{tikzpicture}
	\label{stress_func_plot}
	\caption{Visualization of the proposed stress function with $c = 0.1$ (surface) and with $c = 100$ (mesh)}
\end{figure}

This function gives a good measure of how urgently a certain traffic signals wants to switch to green. The stress value can then be used to find the signal group with the highest priority and switch its signals to the green state. This however would lead to the problem, that heavily congested lanes would usually take priority and become green even though no vehicle can actually move on these lanes. In order to lower the chance of that happening a second measure is introduced: Back pressure. This gives a measure for how congested the outgoing lanes of a signal are and is defined by \autoref{backpressure_signal} for a single signal. $s$ is the signal, $n$ is the number of outgoing lanes for this signal and $s_i$ is the amount of cars waiting in the $i$-th outgoing lane.

\begin{equation} \label{backpressure_signal}
b(s) = \sqrt{\sum_{i}^{n}{s_{i}^2}}
\end{equation}

This is basically the length of vector of the amounts of cars of the outgoing links. This was chosen in order to give the main weight to the ''fullest`` lane while still allowing the free lanes to reduce the value. The resulting values are normalized to the maximum (biggest value will be $1$, smallest value will be $0$). The values will then be used to calculate the stress-reducing factor with \autoref{stress_reducer}, where $x$ is the normalized back pressure and $r$ is the maximum reduction factor:

\begin{equation} \label{stress_reducer}
	f(x) = r (1 - x) + (1 - r)
\end{equation}

That factor is than applied to the stress value on a per signal basis. That way the frequency of congested lanes will be reduced and less congested lanes will preferred.

Both values, the stress and the back pressure rely on the quality of the predictions. Over-predicting the number of cars might produce to much stress or an unnecessary strong reduction. Under-predicting the number may produce incorrect priorities and depending on the stress function lead to no stress at all. So the stress function should protect against this case for example with a content minimum amount of cars (as seen in \autoref{proposed_stress}).

\subsection*{Phase duration}

It is now possible to order the phases by their urgency, but the phases have a duration of zero at the moment. The calculation of the phase duration for a single signal is a simple linear function on the number of vehicles waiting in front of the traffic light. The number of cars is multiplied by a constant amount of time that a car has available to drive towards the signal. In order to prevent a duration of zero, the resulting value is lower-bounded, a useful value could be one vehicle duration, so at least one car is able to pass the intersection. This function could also lead to very long durations, for example a heavily congested lane, so the time will also be upper-bounded with a multiple of the vehicle duration. The resulting function can be seen in \autoref{phase_duration}

\begin{equation} \label{phase_duration}
t(n)=max\left(t_{min}, min\left(t_{max}, c \cdot n\right)\right)
\end{equation}

If a signal has multiple outgoing lanes, simply the longest duration should be taken for the whole group, because shorter durations are obviously contained in that.

\section{Prediction Network}
\label{predictionNetwork}

- Neural networks. Is there a pattern how to  generate the neural network? Should it grow on its own? What type of neural network do we need?

The prediction network will predict where cars will go in the network. Simplicity will be the design goal with the prediction network. This is based on the fact that the amount of training data rises fast, the more complex a artificial neural network architecture gets. The traffic light control system should give reliably good results and complex artificial neural network can introduce hurdles for the setup of a system, if huge amounts of training data is needed to get passable results. 

There are two general options on building the prediction network. The first one being to use only one artificial neural network that gets fed the current state of the road network and puts out the state for the next time step. The other option is to use one artificial neural network for every decision point in the road network where vehicles can chose between different road to drive down.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/predictionNetworkAlt1}
  \caption[Prediction Network General Architecture Alternative 1]{Prediction Network General Architecture Alternative 1 \protect\footnotemark}
  \label{predictionNetworkAlt1}
\end{figure}

\footnotetext{own illustration}

Figure \ref{predictionNetworkAlt1} shows the first alternative for the prediction network architecture. In this example there is a road network with four road crossings (C1, C2, C3, C4). The parallel lines that are close together show the two lanes of each road. 

As said earlier the first possibility to design the prediction network is to feed the state of the road network through a neural network that maps the whole road network every time step. This means in the state of the road network is defined as a collection of the amount of cars that currently are on each road segment. A road segment would be from a point where multiple roads cross or an endpoint to a point where multiple roads cross or an endpoint. The prediction network would then be fed this current state and put out the state that is valid for the next period of time. This could be a second, ten seconds or anything that was defined before the training data was collected.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/predictionNetworkAlt2}
  \label{predictionNetworkAlt2}
  \caption[Prediction Network General Architecture Alternative 2]{Prediction Network General Architecture Alternative 2 \protect\footnotemark}
\end{figure}

\footnotetext{own illustration}

Figure \ref{predictionNetworkAlt2} shows the second option for the prediction network architecture. This example uses the same road network as the first, but instead of having one artificial neural network that maps the whole state of the road network, there are neural networks for every decision point in the road network instead. This means for every point in the road where a vehicle can drive down multiple ways an artificial neural network is placed.

These networks get as input the current time in a previously defined granularity. This can range from one input node for the day of the week and one for the hour of the day to seconds. The rest of the prediction will take place in the traffic tracker with this option, so the prediction network is only needed when a vehicle approaches a decision point.

These two architectures both have advantages and disadvantages that are now detailed to, at the end, chose one alternative that fits the problem of a simple and reliable prediction network better.

The advantage of the first alternative is that it can discover correlations between all road crossings. It would be possible that when there is some amount of vehicles at crossing C1 that this has an impact on the routes of the vehicles crossing C4. This correlation could not be discovered by the second option, but comes at the cost of an exponential growth of interconnections between neurons in the network over the complexity of the road network, which will require lots of training data to learn the network. This would slow down the launch of such an architecture in the real world significantly, because a lot of data would have to be collected. With the second alternative the amount of interconnections between neurons only grows linear.

A disadvantage of the first alternative is that it could even be impossible to run the traffic light control system without huge data sets, because the artificial neural network would have to learn the structure of the road network. If the neural networks are only attached to each decision point they only have to learn the correlation between time and the amount of cars that drive down each way. They do not have to learn the structure of the road network.

This leads into the advantage of the second alternative that it uses the traffic tracker to do most of the prediction, meaning the traffic tracker will simulate the vehicles driving from decision point to decision point and only then the prediction network will be used to determine where they drive further.

Another advantage of the second alternative is its extensibility. When the artificial neural networks were learned for a part of a road network, they can be reused, if the traffic light control system wants to be used on bigger part of the road network. This is because the decision points are independent of each other. This is not possible with the first alternative, because there all neurons of all segments are interconnected and existing weights may be entirely wrong with new interconnections.

The focus for the prediction network is on simplicity and reliability. This is more represented by the second alternative, because it will require less training data and is less complex in big road networks. Thus, it is chosen as the concept for the prediction network. The exact implementation of which input and output values and what learning rule and artificial neural network type to chose will be tested and documented in the next chapter, but a class diagram for the prediction network can be seen in figure \ref{predictionNetwork}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/predictionNetwork}
  \label{predictionNetwork}
  \caption[Class Diagram Prediction Network]{Class Diagram Prediction Network \protect\footnotemark}
\end{figure}

\footnotetext{own illustration}

The prediction network will mainly contain a map of decision points to their neural networks. There are two methods. One to get a prediction for a link that leads into a decision point. The second argument of this method is the list of input parameters for the artificial neural networks, like the time of the day. The result is the output of the neural network. The second function is to learn from data sets. Data sets are just sets of input and output values that the artificial neural network learns from.

The neural network has a list of layers, the first being the input layer and the last being the output layer and a learning rule. Similar to the prediction network, the neural network has a function to predict from a list of input values and a function to learn.

\section{Traffic Tracker}
\label{trafficTracker}

analogy of error correction problem with neural networks

\section{Traffic Simulation Requirements}
\label{trafficSimulationRequirements}

After the architecture was now constructed the requirements for the traffic simulation software can be gathered. The requirements of all the components, interacting with the traffic simulation, and the developers, who have to debug and test the traffic control system, were taken into account. They were found by brainstorming and beforehand analyzing simulation software to know what to look out for when choosing the right simulation software. The collection of requirements is shown in table \ref{simulationRequirements}.

\begin{table}[!ht]
  	\centering
  	\begin{longtabu}{lp{9cm}l}
  		\rowfont{\bfseries}
		ID & Requirement Name & Priority \\[10pt]
		R1 & Simulation of car traffic & H \\[10pt]
		R2 & Simulation of pedestrian traffic & L \\[10pt]
		R3 & Visual display of the simulation & M \\[10pt]
		R4 & Extensible visual display & L \\[10pt]
		R5 & Interface to read the state of the road network & H \\[10pt]
		R6 & Built in traffic sensors & L \\[10pt]
		R7 & Traffic Lights & H \\[10pt]
		R8 & Dynamic control of traffic lights & H \\[10pt]
		R9 & Visual road network designer & M \\[10pt]
		R10 & Real world data for the simulation & M \\[10pt]
	\end{longtabu}
  	\caption{Traffic Simulation Software Requirements}
  	\label{simulationRequirements}
\end{table}

The requirements are prioritized. The priority high (H) Means that it is impossible to use the simulation software without these requirements. Medium (M) means that it should be possible and these requirements will probably be the deciding factor when choosing between traffic simulations that have all the highly prioritized requirements. Low (L) means that this requirement would be desirable, but is only ``nice to have'' and not needed. The requirements from table \ref{simulationRequirements} are detailed in the next paragraphs.

\paragraph{R1: Simulation of car traffic} The most essential requirement for the traffic simulation chosen for this project is that it can simulate car traffic.

\paragraph{R2: Simulation of pedestrian traffic} Closely coupled with the R1 is the simulation of pedestrian traffic. This will probably be possible in some way with most and may be interesting when further work after this thesis is done, but it is not really needed for this thesis.

\paragraph{R3: Visual display of the simulation} Especially for debugging and testing purposes a visual display of the simulation state is important, but it is no essential feature, where without it the traffic light control system would not be possible, because in a real world scenario the system would probably run without a visual front-end.

\paragraph{R4: Extensible visual display} Again for debugging and testing purposes it is practical to be able to extend the visual display with custom information or control elements. There could for example be labels that show how many vehicles are waiting at a traffic light be attached to each traffic light.

\paragraph{R5: Interface to read the state of the road network} For custom sensors and the training data collector, an interface to read the state of the road network and vehicles is essential. This includes reading how many vehicles are currently at what position of the road, how quick they are able to drive and if they are currently driving or waiting. Preferably there is an application programming interface to use, but an open source software where the information could be exposed in other ways would also be possible.

\paragraph{R6: Built in traffic sensors} A low priority requirement are built in traffic sensors, meaning that the simulation already implements endpoints that simulate traffic sensors like induction loops. This can also be implemented fairly easily with the information required in R5 and is thus a low priority.

\paragraph{R7: Traffic Lights} Traffic lights are like a good interface to the state of the road network another essential requirement. It is not trivial to implement traffic lights in an existing traffic simulation system like traffic sensors.

\paragraph{R8: Dynamic control of traffic lights} Traffic lights can be controlled statically by a time table that contains how long certain traffic light groups stay green or red and in which order they are switched or they are controlled dynamically by a sensor or in this case a more sophisticated traffic light control system. This is important for the traffic light control system to work.

\paragraph{R9: Visual road network designer} There will have to be multiple test networks to test the functionality and performance of the traffic light control system. Huge networks take a long time to built when there is no graphical editor and the editing of a configuration file is error prone.

\paragraph{R10: Real world data for the simulation} Real world data on which to simulate would enable the traffic light control system to be tested in a real scenario and under real conditions.