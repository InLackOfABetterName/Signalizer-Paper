\section{Overview}

This chapter will explain the general concept and architecture of the traffic light control system developed as part of this thesis. The traffic light control system will be built upon an existing traffic simulation, because the thesis is not about the simulation, but the optimization of the traffic light control. Which simulation is chosen will be discussed in a later section of the thesis and is not really relevant here, but the architecture will influence which traffic simulation will be chosen. The requirements for the traffic simulation will be derived from this concept.

\begin{figure}[ht]
  \centering
  \includegraphics[width=16cm]{figures/architecture}
  \label{architecture}
  \caption[Architecture of the Traffic Light Control System]{Architecture of the Traffic Light Control System \protect\footnotemark}
\end{figure}

\footnotetext{own illustration}

The traffic light control system is separated into two general areas, the learning part of the system and the controlling part. Either the system just observes a running traffic simulation and learns the patterns of the traffic or it observes the simulation through traffic sensors and controls the traffic lights according to the predictions combined with the data from the traffic sensors. It is imaginable to let the system learn from a simulation and control it at the same time, but this is outside of the scope of this thesis. But it could possibly improve the results and make it more practicable for a real world deployment.

The control part of the system is the more important. The learning is relatively simple and will be easily interchangeable. This is also the reason why the architecture was split into two parts. With the simulation the data to learn from will be recorded from the simulation itself, but in a real world scenario, data could also be fed from other sources, thus the data collection in the learning part is not a main feature of the traffic light control system and was split from the core control part.

Spanning both the learning and the control part of the system is the prediction network. It is responsible for actually learning the traffic behavior and feeding predictions of the learned behavior back into a real simulation. For this task the prediction network will include an artificial neural network or multiple of them in some form, which is detailed in section \ref{predictionNetwork}. The prediction network will use unsupervised learning to learn the traffic patterns, meaning that there will not be labeled data sets collected beforehand or a continuous interaction with the simulation, but the data sets will be collected from a running traffic simulation.

The traffic recorder will collect such data sets and feed them into the prediction network. Depicted in figure \ref{architecture} is only the default implementation of the traffic recorder which collects the data sets directly from the traffic simulation. The design goal of this component is to split the learning set creation and handling from the prediction network to be flexible and extensible in how data is fed to the prediction network. The default implementation will observe the state of the traffic network and record the data that is compliant to the prediction networks input and output formats. With the component split from the prediction network the creation of data sets is clearly separated from the prediction network. Thus it is, as said earlier, possible to change the way data is fed to the prediction network easily. In a real world scenario, it probably would be nearly impossible to automatically record the data sets and it would be a huge benefit to easily swap out the learning input to some other method, which is possible with this architecture.

In the control part of the system, the interaction with the traffic simulation occurs over traffic sensors that collect data and the traffic light controller that switches the states of the traffic lights. The different traffic sensors that are commonly used already are detailed in section \ref{trafficSensors}. Depending on the traffic simulation software chosen later, they are already part of the simulation or have to be simulated by observing the state of the simulation and extracting the relevant information. The data they need from the simulation and the data they pass on to the next component depends on the type of sensor used. An induction loop may only report if a vehicle currently is on top of it or not, but a camera attached to the traffic light might even count the amount of vehicles waiting for the light to turn green. The traffic light controller has to switch the traffic lights depending on the input he gets from the traffic tracker and is further described in section \ref{trafficLightController}. Like the traffic recorder the goal here was to be able to swap out the layer communicating information to the main components of the traffic light control system. An additional goal for the traffic light controller was to be able to swap out the strategy that it uses to control the traffic lights, but this is discussed in more detail in section \ref{trafficLightController}.

The final component of the architecture is the traffic tracker that keeps all other components together. Its task is to use the prediction network and the traffic sensors to create a picture of reality that has to closely match what is really happening. The traffic tracker can then make a statement about where cars should be in the system and the traffic light controller can then, based upon the traffic trackers data, make decisions how the traffic lights have to be optimally switched. The difficulties arising in this component are various. For example, a traffic sensor could discover that a  prediction made by the prediction network is wrong. This has to be corrected somehow, but with a complex street network it may not be easy to detect where the failure came from. This problem is from now on called the error correction problem. Furthermore traffic sensors may give very vague or heterogeneous data, making it hard to incorporate the data into the picture of reality.

\begin{figure}[ht]
  \centering
  \includegraphics[width=16cm]{figures/errorCorrectionProblem}
  \label{errorCorrectionProblem}
  \caption[Error Correction Problem]{Error Correction Problem \protect\footnotemark}
\end{figure}

\footnotetext{own illustration}

Figure \ref{errorCorrectionProblem} shows an example for the error correction problem. In this example two vehicles V1 and V2 depicted in green entered at the road crossing C4. (1) Here the first prediction was that one car drives to C1 and the other one drives to C5. (2) This prediction is only based on the learned traffic patterns and could be completely wrong, but should in the most cases be right.

When V1 enters crossing C1 the prediction is that it drives to C2. The prediction for V2 is that it continues from C5 to C2. (3) In the example, crossing C6 is equipped with induction loops and detects when a vehicle enters the crossing.

Finally a vehicle is detected at C6, but in the traffic tracker all vehicles in the network are at other positions and no vehicle was predicted to drive there. This is not trivial to solve and could be solved in many different ways. Either V1 or V2 could be predicted wrong. The correction, if V2 would be wrong, is straight forward. V2 is just moved to the crossing, but if V1 is chosen to be moved there, it could have had implications on the prediction at crossing C5, where the prediction was made with one vehicle, but should then have been made with two. This could then spawn new errors in the network that would have to be resolved.

With this really simple example alone, it can be seen how difficult it is, to resolve errors in a complex network that are detected by traffic sensors. With more vehicles and more crossings the problem becomes even bigger. A solution algorithm for these problems will be implemented by the traffic tracker which is discussed in more detail in section \ref{trafficTracker}.

With this architecture it should be possible to experiment with different traffic sensors and traffic light controllers. This is a huge benefit, because experimentation will especially be important when trying to find the best setup of sensors and controller when later evaluating different possibilities to use the traffic light control system.

\section{Traffic Light Controller}
\label{trafficLightController}

This component is the executive part of the architecture. It assembles the information gathered in the traffic network into traffic signal switching plans. Every street intersection, small or big, has its own controller instance managing just this intersection. One specific controller represents one specific switching strategy. The switching strategy can be decided on a per-intersection basis. This way a street network can be setup with differently controlled intersections in order to test mixed networks.

All controllers have a Traffic Network Controller as their parent, which can act as a communication bus between traffic light controllers. The network controller is also a lower-level integration, from the perspective of a per-intersection controller, into the simulation software. It can capture generic events and direct them to affected local controllers, as it is the instance in the system that knows all intersection controllers.

A signal controller, or local controller, manages the intersections signals in a system, which holds the signals themselves as well as the groups including the mappings from groups to signals and vice versa.

This results in the entity relationships shown in \autoref{sig_ctrl_relations}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=13cm]{figures/signal_light_controller}
	\label{sig_ctrl_relations}
	\caption{Entity relationships inside the Traffic Light Controller}
\end{figure}

From now on the term ''signal controller`` will refer to the intersection local controllers. Its the responsibility of these controllers to decide which lights to switch to green and for how long. In contrast to the commonly applied concepts of cycles and splits (as seen in \autoref{analysis}), these controllers will use a different approach. Instead of having a fixed cycle time separated into splits per phase, a priority queue like approach has been chosen to define the order of phases and a load based function is applied to decide the length of the given phase.

Even though the individual lanes and their sensor data will be used as input, switching is done on a signal group level. Signal groups will always be switched as one unit and as such, decisions are not made on a signal level, but instead considering all signals of a group.

\subsection*{Grouping signals}
\label{signal_group_concept}

In order to do signal switching on a group basis, the groups have to be defined first. A simple yet effective approach to defining the signal groups of an intersection is to manually inspect the intersection and define the groups by hand. This allows very specific grouping rules and easy special casing where needed or beneficial. With only a few intersections (for example in a small town) this is an acceptable solution.

However as one of the goals of the project is to reduce manual input and the resulting advantages in large street networks with many intersections, an automated approach has been chosen. Signals can be grouped in a lot of different ways depending on the intersection layout and applicable priority rules. In the real world, many intersections allow two green lanes to intersect each other, often seen when the intersecting lane is a low traffic lane. This increases the complexity of finding suitable groups and also poses a driver security risk, as opposing drivers may not expect an vehicle intersecting his lane.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=6cm]{figures/intersecting_green}
	\label{intersecting_green}
	\caption{Intersection pattern with intersecting green lanes (marked red).}
\end{figure}

\autoref{intersecting_green} shows a pattern that is common in German cities where the traffic to the opposing street is infrequent.

The approach chosen in this project should not allow conflicting green lanes and thus increase driver safety. Two lanes are in conflict, if they either intersect each other at any point or if they merge into one lane as part of the intersection. The lane from the top to the bottom and the lane from the bottom to the left in \autoref{intersecting_green} would not be allowed, because they intersect. The lane from the top to the left and the lane from the bottom to the left don't intersect, but would still not be allowed in the same group, as they merge into one lane. The approach should also produce a minimal set of signal groups without any redundant groups. A group is redundant if it is entirely contained within another group.

As an high level algorithm, this would contain the following steps:

\begin{enumerate}
	\item Construct the set of all potential groups as the power set of the set of signals.
	\item Remove all groups that contain a signal pair with intersecting lanes
	\item Remove all groups that contain a signal pair with merging lanes
	\item Remove all groups that are contained within another group
	\item The remaining groups are minimal and conflict free
\end{enumerate}

Building and filtering a power set is exponential ($\mathcal{O}(2^n)$) both in runtime and memory costs, however constructing the signal groups is usually done once for a given intersection and the number of signals is unlikely to become big enough, that the computation of the groups would not be possible in an acceptable amount of time. For an unrestricted intersection, which is the largest intersection for this project with twelve signals, the algorithm would produce the group patterns shown in \autoref{signal_group_pattern}. The patterns one to three can be rotated 3 times, the pattern four and five once, resulting in 17 unique signal groups.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=14cm]{figures/signal_group_patterns}
	\caption{Possible patterns of signal groups produced by the given algorithm. Most patterns can be rotated.}
	\label{signal_group_pattern}
\end{figure}

Further details of the algorithm and implementation specialties are described in \autoref{scenario_generation}.

\subsection*{Priority}
\label{stress_prio}

In order to use a priority queue, there must be a measure of priority. The measure proposed for this is called a stress function referring to commuter stress (see \autoref{commuter_stress}). The idea is simple: Waiting for a long time in front of a red traffic light causes increasing amounts of stress and waiting in a very long queue is worse than waiting as the first vehicle in line.

As such we can define a stress function for an individual signal as follows: $s(n, t): \mathbb{R}^2 \mapsto \mathbb{R}$ with $n$ being the number of vehicles waiting at a signal and $t$ being the time since the signal last was in the green state. The overall stress of a signal group is then calculated with $S(n, t)$ as seen in \autoref{group_stress}. $N$ is the number of signals in the group and $s\left(n_i, t_i\right)$ is the stress of the current signal. The main goal is, that the stress of a signal with a few vehicles waiting for a long time will eventually surpass the stress of a signal with a lot of vehicles waiting for a shorter time. 

\begin{equation} \label{group_stress}
	S(n, t) = \sum_{i}^{N}{s\left(n_i, t_i\right)}
\end{equation}

Including the wait/red time in the function is quite important. A naive approach could just use the number of vehicles in front of the signals, but this can lead to starvation problems (certain lanes not getting any time at all). This will happen if two signal groups receive a lot of new vehicles in a short time while other groups only receive a small number of vehicles. In these cases the signal controller would oscillate between the two high input groups and completely ignore other groups until the input of these active groups decreases, which can take hours during a common ''rush hour`` on main streets.

A proposed definition for $s(n, t) $ is shown in \autoref{proposed_stress}. The value for $c$ is constant and can be freely chosen from $\mathbb{R}$ to guarantee a certain stress buildup per time unit even if no vehicles are detected at the signal. A visualization of this function can be seen in \autoref{stress_func_plot} with two values for $c$.

\begin{equation} \label{proposed_stress}
	s(n, t) = (n + t)(n + c)
\end{equation}

The function has been modeled, so it has the main emphasize on the vehicle count (quadratic influence) while still allowing the time (linear influence) to overtake eventually. Simpler functions like $s(n, t) = n + t$ have been considered, but were finally discarded due to the balanced influence and thus overemphasize the time.

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
		zmin=0,
		xlabel={Time},
		ylabel={Vehicle count},
		zlabel={Stress}
	]
	\addplot3[surf, samples=15, domain=0:150]{
		(x + y) * (x + 0.1)
	};
	\addplot3[mesh, samples=15, domain=0:150]{
		(x + y) * (x + 100)
	};
	\end{axis}
	\end{tikzpicture}
	\label{stress_func_plot}
	\caption{Visualization of the proposed stress function with $c = 0.1$ (surface) and with $c = 100$ (mesh)}
\end{figure}

This function gives a good measure of how urgently a certain traffic signal needs to switch to green. The stress value can then be used to find the signal group with the highest priority and switch its signals to the green state. This however would lead to the problem, that heavily congested lanes would usually take priority and become green even though no vehicle can actually move on these lanes. In order to lower the chance of that happening a second measure is introduced: Back pressure. This gives a measure for how congested the outgoing lanes of a signal are and is defined by \autoref{backpressure_signal} for a single signal. $s$ is the signal, $n$ is the number of outgoing lanes for this signal and $s_i$ is the amount of vehicles waiting in the $i$-th outgoing lane.

\begin{equation} \label{backpressure_signal}
b(s) = \sqrt{\sum_{i}^{n}{s_{i}^2}}
\end{equation}

This is basically the length of the vector of the amounts of vehicles of the outgoing links. This was chosen in order to give the main weight to the ''fullest`` lane while still allowing the free lanes to reduce the value. The resulting values are normalized to the maximum (biggest value will be $1$, smallest value will be $0$). These values will be used to calculate the stress-reducing factor with \autoref{stress_reducer}, where $x$ is the normalized back pressure and $r$ is the maximum reduction factor:

\begin{equation} \label{stress_reducer}
	f(x) = r (1 - x) + (1 - r)
\end{equation}

That factor is than applied to the stress value on a per signal basis. That way the frequency of congested lanes will be reduced and less congested lanes will preferred.

Both values, the stress and the back pressure rely on the quality of the predictions. Over-predicting the number of cars might produce to much stress or an unnecessarily strong reduction. Under-predicting the number may produce incorrect priorities and, depending on the stress function, lead to no stress output at all. So the function should protect against this case, for example with a constant minimum amount of vehicles (as seen in \autoref{proposed_stress}).

\subsection*{Phase duration}

It is now possible to order the phases by their urgency, but at the moment the duration of a phase is still undefined. The calculation of the phase duration for a single signal is a simple linear function on the number of vehicles waiting in front of the traffic light. The number of cars is multiplied by a constant amount of time that a car has available to drive towards the signal. In order to prevent a duration of zero, the resulting value is lower-bounded, a useful value could be one vehicle duration, so at least one car is able to pass the intersection. This function could also lead to very long durations, for example a heavily congested lane, so the time will also be upper-bounded with a multiple of the vehicle duration. The resulting function can be seen in \autoref{phase_duration}

\begin{equation} \label{phase_duration}
t(n)=max\left(t_{min}, min\left(t_{max}, c \cdot n\right)\right)
\end{equation}

If a signal has multiple outgoing lanes, simply the longest duration should be taken for the whole group, because shorter durations are obviously contained in that.

\section{Prediction Network}
\label{predictionNetwork}

The prediction network will predict where cars will go in the network. Simplicity will be the design goal with the prediction network. This is based on the fact that the amount of training data rises fast, the more complex a artificial neural network architecture gets. The traffic light control system should give reliably good results and complex artificial neural network can introduce hurdles for the setup of a system, if huge amounts of training data is needed to get passable results. 

There are two general options on building the prediction network. The first one being to use only one artificial neural network that gets fed the current state of the road network and puts out the state for the next time step. The other option is to use one artificial neural network for every decision point in the road network where vehicles can chose between different roads to drive down.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/predictionNetworkAlt1}
  \caption[Prediction Network General Architecture Alternative 1]{Prediction Network General Architecture Alternative 1 \protect\footnotemark}
  \label{predictionNetworkAlt1}
\end{figure}

\footnotetext{own illustration}

Figure \ref{predictionNetworkAlt1} shows the first alternative for the prediction network architecture. In this example there is a road network with four road crossings (C1, C2, C3, C4). The parallel lines that are close together show the two lanes of each road. 

As said earlier the first possibility to design the prediction network is to feed the state of the road network through a neural network that maps the whole road network every time step. This means in the state of the road network is defined as a collection of the amount of cars that currently are on each road segment. A road segment would be from a point where multiple roads cross or an endpoint to a point where multiple roads cross or an endpoint. The prediction network would then be fed this current state and put out the state that is valid for the next period of time. This could be a second, ten seconds or anything that was defined before the training data was collected.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/predictionNetworkAlt2}
  \caption[Prediction Network General Architecture Alternative 2]{Prediction Network General Architecture Alternative 2 \protect\footnotemark}
  \label{predictionNetworkAlt2}
\end{figure}

\footnotetext{own illustration}

Figure \ref{predictionNetworkAlt2} shows the second option for the prediction network architecture. This example uses the same road network as the first, but instead of having one artificial neural network that maps the whole state of the road network, there are neural networks for every decision point in the road network instead. This means for every point in the road where a vehicle can drive down multiple ways an artificial neural network is placed.

These networks get as input the current time in a previously defined granularity. This can range from one input node for the day of the week and one for the hour of the day to seconds. The rest of the prediction will take place in the traffic tracker with this option, so the prediction network is only needed when a vehicle approaches a decision point.

These two architectures both have advantages and disadvantages that are now detailed to, at the end, chose one alternative that fits the problem of a simple and reliable prediction network better.

The advantage of the first alternative is that it can discover correlations between all road crossings. It would be possible that when there is some amount of vehicles at crossing C1 that this has an impact on the routes of the vehicles crossing C4. This correlation could not be discovered by the second option, but comes at the cost of an exponential growth of interconnections between neurons in the network over the complexity of the road network, which will require lots of training data to learn the network. This would slow down the launch of such an architecture in the real world significantly, because a lot of data would have to be collected. With the second alternative the amount of interconnections between neurons only grows linear.

A disadvantage of the first alternative is that it could even be impossible to run the traffic light control system without huge data sets, because the artificial neural network would have to learn the structure of the road network. If the neural networks are only attached to each decision point they only have to learn the correlation between time and the amount of cars that drive down each way. They do not have to learn the structure of the road network.

This leads into the advantage of the second alternative, that it uses the traffic tracker to do most of the prediction, meaning the traffic tracker will simulate the vehicles driving from decision point to decision point and only then the prediction network will be used to determine where they drive further.

Another advantage of the second alternative is its extensibility. When the artificial neural networks were learned for a part of a road network, they can be reused, if the traffic light control system wants to be used on bigger part of the road network. This is because the decision points are independent of each other. This is not possible with the first alternative, because there, all neurons of all segments are interconnected and existing weights may be entirely wrong with new interconnections.

The focus for the prediction network is on simplicity and reliability. This is more represented by the second alternative, because it will require less training data and is less complex in big road networks. Thus, it is chosen as the concept for the prediction network. The exact implementation of which input and output values and what learning rule and artificial neural network type to chose will be tested and documented in the next chapter, but a class diagram for the prediction network can be seen in figure \ref{predictionNetwork}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/predictionNetwork}
  \caption[Class Diagram Prediction Network]{Class Diagram Prediction Network \protect\footnotemark}
  \label{predictionNetwork}
\end{figure}

\footnotetext{own illustration}

The prediction network will mainly contain a map of decision points to their neural networks. There are two methods. One to get a prediction for a link that leads into a decision point. The second argument of this method is the list of input parameters for the artificial neural networks, like the time of the day. The result is the output of the neural network. The second function is to learn from data sets. Data sets are just sets of input and output values that the artificial neural network learns from.

The neural network has a list of layers, the first being the input layer and the last being the output layer and a learning rule. Similar to the prediction network, the neural network has a function to predict from a list of input values and a function to learn.

\section{Traffic Tracker}
\label{trafficTracker}

The traffic tracker has two main tasks, simulating the traffic in the road network based of the predictions from the prediction network and correcting errors based of data from the traffic sensors. The primary design goal for the traffic tracker is its correctness when the prediction network is correct. A secondary goal would be to be able to add new traffic sensors easily.

The interface to the prediction network is already defined, but the interfaces to the traffic light controller and the traffic sensors is not. The traffic light controller has to have a way to retrieve how many vehicles are at a road segment, called link. Thus, the traffic tracker will have a function ``vehicleCountAt'' which takes an id of a link and returns the vehicle count at that link. The interface to the traffic sensors is more difficult, because it is not yet clear how the error correction will work and this is the main use of the traffic sensors. The interface to the traffic sensors will be defined later.

The problem with traffic sensors is that they come in many different forms and produce very different information on which an error correction could take place. Induction loops may only be able to signal if a car is there or not, a camera might only be able to recognize up to seven vehicles and other systems might have totally different restrictions. Thus, two general options to implement the error correction come up. One, where the error correction takes place in the traffic tracker itself, called by events produced by the traffic sensors, and one, where the traffic tracker calls the sensors to correct possible errors. 

\begin{figure}[!ht]
  \centering
  \includegraphics[width=14cm]{figures/trackerSensorInterface}
  \caption[Traffic Tracker Sensor Interface]{Traffic Tracker Sensor Interface \protect\footnotemark}
  \label{trafficTrackerSensorInterface}
\end{figure}

Figure \ref{trafficTrackerSensorInterface} shows the two options described in the previous paragraph. The first one would enable the traffic sensors to be really light weight. They would have to know nothing about the traffic tracker and implement almost no logic. New traffic sensors, that would use the same error correction mechanisms as previous ones, would be very easy to implement, but if a new traffic sensor with data, that could not be used with the existing error correction mechanism, would have to be connected to the traffic tracker, the traffic tracker would have to implement another mechanism for error correction. Users with their own traffic sensors would have to have their own implementation of the traffic tracker.

The alternative where the traffic tracker calls the traffic sensors to correct errors would require more work to implement a traffic sensor, because every one would have to implement its own error correction and the traffic sensors would have to know at least the internal data format of the traffic tracker to correct it. However, traffic sensors would work with every implementation of the traffic tracker and the problem of every traffic sensor implementing its own error correction could be solved with abstract sensors that implement different error correction methods that are then inherited for a new traffic sensor.

The traffic tracker will implement the second option, where the traffic tracker calls the sensors, because it is more extensible, mostly because the traffic tracker will not have to implement different error correction mechanisms. Secondly, it also is more flexible.

To be able to return how many vehicles are at a link, the traffic tracker has to have an internal data model of links and vehicles. The traffic tracker will have many links that are interconnected and the links will have a queue of tracked vehicles that drive on the link and possibly wait at the end until the next link has enough free space or the traffic light turns green. ``TrackedLink'' and ``TrackedVehicle'' will be the two data objects that only contain some helper functions. The simulation, which will move the vehicles in the road network, will take place in the traffic tracker.

If, in the traffic tracker simulation, a vehicle approaches a decision point with for example two roads where the vehicle can continue, there are two options how to resolve the decision. Either, a random number between 0 and 1 is generated and the route in which range the number lies is taken. When the prediction network would return an array $[0.3, 0.7]$, which resembles the probabilities, the vehicle drives down this certain route, and the random number would be $0.12$, the first route would be taken. Or, the vehicles have a probability attached to them and at each decision point the vehicle is split apart and each part gets at its probability the probability of the old vehicle times the probability of this route. With a vehicle with the probability $0.5$ and the returned array $[0.3, 0.7]$ of the prediction network, the new vehicles probabilities would be $0.15$ and $0.35$.

The random number option is easier to implement and has fewer implications on the performance, but then the error correction becomes really hard. There are two types of errors that need to be corrected. Either there are more cars on the simulated tracked link than the traffic sensors detects or there are too few cars on the simulated tracked link. With too many cars, with the random number solution, the car could be moved to another link that is a possible route, but the error is hard to find in the many routes the vehicle could have taken. With the probability option, every vehicle could remember all split clones of this vehicle and could remove itself from the link by evenly distributing its probability to the other parts of the vehicle.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=16cm]{figures/splitVehicles}
  \caption[Traffic Tracker Error Correction]{Traffic Tracker Error Correction \protect\footnotemark}
  \label{trafficTrackerErrorCorrection}
\end{figure}

Figure \ref{trafficTrackerErrorCorrection} shows the case that there are too few vehicles on a link. The first row describes the random number solution, where two vehicles enter the road crossing with a $70\%$ probability of driving up.(1) They may both drive upwards.(2) Then the induction loop at the road crossing C4 detects a vehicle standing there.(3) Even in this reduced example, with the random number solution it is not clear what vehicle of the two to move to C4. With more complex routes it could be possible that hundreds of vehicles could be moved there.

The second row of figure \ref{trafficTrackerErrorCorrection} shows how two vehicles with $100\%$ probabilities drive up to the road crossing.(1) Both vehicles drive both ways and split up, but the two vehicles driving up now only have a probability of $70\%$ left.(2) When the induction loop now detects that there should be a vehicle (3), but there is only $0.6$ vehicles, it can correct the error by taking $20\%$ away from both vehicles driving up and adding it to the ones standing at C4.

The second solution does not only make error correction easier, but also makes the result more correct and less error prone, because no random numbers are used anymore. Thus, the second option is chosen over the first.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=14cm]{figures/trackerClassDiagram}
  \caption[Class Diagram Traffic Tracker]{Class Diagram Traffic Tracker \protect\footnotemark}
  \label{trafficTracker}
\end{figure}

Figure \ref{trafficTracker} shows the complete class diagram of the traffic tracker, its interfaces to the connected components and its data model with tracked links and vehicles.

Most of this was already explained in this section. The ``currentLinkEnteredTime'' is used to calculate when the vehicle reached the end of the link and is ready to go to the next link. The ``split'' function is a helper function to split up the vehicle at decision point with a list of probabilities for the new vehicles. It also maintains the ``clones'' list which contains all the vehicles that were at some point split of of this vehicle.

\section{Traffic Simulation Requirements}
\label{trafficSimulationRequirements}

After the architecture was now constructed the requirements for the traffic simulation software can be gathered. The requirements of all the components, interacting with the traffic simulation, and the developers, who have to debug and test the traffic control system, were taken into account. They were found by brainstorming and beforehand analyzing simulation software to know what to look out for when choosing the right simulation software. The collection of requirements is shown in table \ref{simulationRequirements}.

\begin{table}[!ht]
  	\centering
  	\begin{tabular}{l|p{9cm}c}
		ID & Requirement Name & Priority \\
		\hline\hline
		R1 & Simulation of car traffic & H \\
		R2 & Simulation of pedestrian traffic & L \\
		R3 & Visual display of the simulation & M \\
		R4 & Extensible visual display & L \\
		R5 & Interface to read the state of the road network & H \\
		R6 & Built in traffic sensors & L \\
		R7 & Traffic Lights & H \\
		R8 & Dynamic control of traffic lights & H \\
		R9 & Visual road network designer & M \\
		R10 & Real world data for the simulation & M \\
	\end{tabular}
  	\caption{Traffic Simulation Software Requirements}
  	\label{simulationRequirements}
\end{table}

The requirements are prioritized. The priority high (H) means that it is impossible to use the simulation software without this requirement. Medium (M) means that it should be possible and this requirement will probably be the deciding factor when choosing between traffic simulations that have all the highly prioritized requirements. Low (L) means that this requirement would be desirable, but is only ``nice to have'' and not needed. The requirements from table \ref{simulationRequirements} are detailed in the next paragraphs.

\paragraph{R1: Simulation of car traffic} The most essential requirement for the traffic simulation chosen for this project is that it can simulate car traffic.

\paragraph{R2: Simulation of pedestrian traffic} Closely coupled with the R1 is the simulation of pedestrian traffic. This will probably be possible in some way with most and may be interesting when further work after this thesis is done, but it is not really needed for this thesis.

\paragraph{R3: Visual display of the simulation} Especially for debugging and testing purposes a visual display of the simulation state is important, but it is no essential feature, where without it the traffic light control system would not be possible, because in a real world scenario the system would probably run without a visual front-end.

\paragraph{R4: Extensible visual display} Again for debugging and testing purposes it is practical to be able to extend the visual display with custom information or control elements. There could for example be labels, that show how many vehicles are waiting at a traffic light be attached to each traffic light.

\paragraph{R5: Interface to read the state of the road network} For custom sensors and the training data collector, an interface to read the state of the road network and vehicles is essential. This includes reading how many vehicles are currently at which position of the road, how quickly they are able to drive and if they are currently driving or waiting. Preferably there is an application programming interface to use, but an open source software where the information could be exposed in other ways would also be possible.

\paragraph{R6: Built in traffic sensors} A low priority requirement are built in traffic sensors, meaning that the simulation already implements endpoints that simulate traffic sensors like induction loops. This can also be implemented fairly easily with the information required in R5 and is thus a low priority.

\paragraph{R7: Traffic Lights} Traffic lights are like a good interface to the state of the road network another essential requirement. It is not trivial to implement traffic lights in an existing traffic simulation system like traffic sensors.

\paragraph{R8: Dynamic control of traffic lights} Traffic lights can be controlled statically by a time table that contains how long certain traffic light groups stay green or red and in which order they are switched or they are controlled dynamically by a sensor or in this case a more sophisticated traffic light control system. This is important for the traffic light control system to work.

\paragraph{R9: Visual road network designer} There will have to be multiple test networks to test the functionality and performance of the traffic light control system. Huge networks take a long time to built when there is no graphical editor and the editing of a configuration file is error prone.

\paragraph{R10: Real world data for the simulation} Real world data on which to simulate would enable the traffic light control system to be tested in a real scenario and under real conditions.